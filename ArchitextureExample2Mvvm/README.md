# Пример Android MVVM (вид сверху)

На что обратить внимание:

Справедливо все то же что было скзано на первом вебинаре:

- Следует различать архитектуру ОС и архитектуру приложения (Activity это часть архитектуры Android, интерфейс операционной системы с которой взаимодействует наше приложение, а MVC же относится к архитектуре нашего приложения)

- Каждый архитектурный класс (Model, View, Controller и т.п.) является посредником между логикой приложения (Model в MVC) и каким-то реальным субъектом (Пользователь, Сервер, ОС и т.п.)

- Смотрите чего не хватает на схеме, дополняйте (В MVC не хватает бэкенда и операционки к примеру)

- View и Controller для тачскрина объединяются во ViewController 

- Архитектурных классов любого типа(Model, ViewController, Backend и т.п.) может быть 1 или несколько, или не быть совсем, в зависимости от необходимости

- В комментариях к класам указаны отсылки к другим подобным по функционалу архитектурным названиям

- Для наглядности к архитектурным классам добавлены ярлыки-интерфейсы. Классы могут называться как угодно, а ярлыки указывают на то какую функцию они выполняют.

- [Класс View андроида] != [класс View MVC]

Плюс для MVVM:

- [Android MVVM] != [Original Microsoft MVVM] (оккуратнее со схемами, есть некоторая путаница)

- [Android MVVM View] == [Original MVVM ViewModel] (если речь идет не о DataBinding, с ним схема сходится)
Класс отвечает за передачу событий вью в модель приложения, и за обновление UI на события от модели приложения.

- [Android MVVM ViewModel] == [Original MVVM Model] 
Класс является моделью приложения, содержит бизнес-логику, получает события и данные из всех возможных источников (User, Backend, System и т.п.).

- [Android MVVM Model] == [получение данных с сервера, или модель этих данных]
Нет конкретного класса, некоторые называют моделью модель данных что получаем с сервера, некоторые называют моделью классы которые получают данные с сервера, типа Repository. (Это не согласуется с оригиналом, но так исторически сложилось)

- [Android ViewModel] примерно равно [Presenter из MVP] и примерно равно [Model из MVC]

- Android [ViewModel] отличается от MVP [Presenter]-а и от MVC [Model] способом поставки данных/событий во внешние классы. Тут используется паттерн Observer, любой реализации (LiveData, Flow, Rx), из вьюмодели эмитятся данные, на получение этих данных можно подписаться. В случае же презентера или модели обычно данные передаются вызовом функции объекта. В первом случае ViewModel не имеет ссылку на класс View, во втором случае класс Presenter\Model имеет ссылку на класс View.

- в Original MVVM отсутствует ViewController, потому как его функцию берет на себя Original ViewModel

- в Android MVVM тоже нет ViewController-а, его функцию берет на себя класс системы(Activity/Fragment). Принято говорить что Activity это View, на самом деле Activity отвечает за взаимодействие с ОС, и дополнительно принимает на себя функции ViewController-а.


